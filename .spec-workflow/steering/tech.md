# 技術スタック & 実現可能性分析

## プロジェクトタイプ
デスクトップアプリケーション（macOS）- 重複ファイル検出・削除ツール

## コア技術

### 主要言語
- **言語**: Python 3.10+
- **ランタイム**: CPython
- **パッケージマネージャー**: `uv` (高速な依存関係解決と環境管理)

### 主要ライブラリ
- **UIフレームワーク**: **Flet** (FlutterのPythonラッパー)
    - *実現可能性*: PythonのみでモダンでレスポンシブなUIを作成可能。動画再生は`flet-video`パッケージで対応可能
    - *リスク*: 
        1. Finderからのドラッグ＆ドロップがネイティブでサポートされていない
        2. 「Finderで表示」などの機能にAppleScript (`osascript`) の呼び出しが必要
    - *軽減策*: 
        1. ファイル選択には標準の`FilePicker`を使用（ドラッグ＆ドロップはv1では非対応）
        2. ネイティブ機能呼び出しには`subprocess`経由でAppleScriptを使用
- **ファイル操作**: `pathlib`, `send2trash`
    - *実現可能性*: ローカルドライブではゴミ箱への移動が可能
    - *注意点*: **ネットワークドライブ上のファイルは`send2trash`でゴミ箱に移動できず、即座に削除される仕様**であるため、ネットワークドライブ上のファイル削除時は明示的な警告ダイアログを実装する
- **並行処理**: `concurrent.futures`, `asyncio`
    - *実現可能性*: 重いI/O操作（スキャン/ハッシュ計算）中のUIフリーズ防止に必須

## アプリケーションアーキテクチャ

### MVVMパターン
- **Model**: データ構造（`FileMeta`, `DuplicateGroup`）とビジネスロジック（`Scanner`, `Hasher`）
- **View**: Flet UIコンポーネント
- **ViewModel**: ViewとModelを接続し、状態とユーザーイベントを処理

## 実現可能性分析 & 技術的決定

### 1. パフォーマンス: 大規模データセット & ネットワークドライブの処理
**課題**: NASやクラウドドライブ上の数千のファイルをスキャンすると極端に遅くなり、UIがブロックされる可能性がある
**解決策**:
- **非同期スキャン**: スキャンとハッシュ計算をバックグラウンドスレッド/プロセスで実行し、UIの応答性を維持
- **部分ハッシュ戦略**:
    1.  **サイズフィルター**: まずファイルサイズを比較。サイズが異なる = 重複ではない
    2.  **部分ハッシュ**: サイズが一致するファイルの先頭4KBと末尾4KBのみを読み取る
    3.  **完全ハッシュ**: 部分ハッシュが一致した場合のみ、完全なMD5/SHA256ハッシュを計算
    - *影響*: ネットワークI/Oを大幅に削減し、NASスキャンを実現可能にする

### 2. UI/UX: Fletによるモダンな美観
**課題**: クロスプラットフォームフレームワークで「プレミアム」な感覚を作り出す
**解決策**:
- Fletの組み込みMaterial Design 3コントロールを使用
- カスタムテーマ（ダークモード、カラースキーム）を実装してmacOSの美観に合わせる
- 一貫性を保つために再利用可能なコンポーネントとして`UserControl`を使用

### 3. 安全性: ファイル削除
**課題**: 重要なファイルの誤削除
**解決策**:
- **主要方法**: `send2trash`を使用してmacOSゴミ箱にファイルを移動
- **フォールバック**: ゴミ箱がサポートされていない場合（一部のネットワーク共有など）、完全削除前にユーザーに明示的な確認を求める
- **プレビュー**: 選択前にファイルを確認するための堅牢なプレビュー機能（FletのImageコントロールを使用）を実装

### 4. ストレージアクセス: クラウド & NAS
**課題**: 多様なプロトコル（SMB、AFP、Google Drive File Stream）
**決定**: すべてのストレージを**ローカルファイルシステムパス**として扱う
- *根拠*: macOS Finderのマウント機能に依存することでアプリロジックが簡素化される。アプリはSMBやGoogle Drive APIを直接実装する必要がない
- *制約*: ユーザーはアプリを使用する前にFinder経由でドライブをマウントする必要がある

## 開発環境

### ビルド & 品質ツール
- **パッケージ管理**: `uv`
- **タスクランナー**: `poethepoet`
- **リンター/フォーマッター**: `ruff` (高速、包括的)
- **型チェック**: `mypy` (strictモード)
- **テスト**: `pytest` + `pytest-xdist` (並列テスト実行)

## 開発ワークフロー

### 標準開発サイクル
以下のワークフローを順守して開発を進めること：

1.  **TDDサイクル (`/tdd-cycle`)**:
    - `git worktree`を用いて機能ごとの環境を作成
    - Red-Green-Refactor (RGR) サイクルでTDDを実施
2.  **品質チェック (`/quality-check`)**:
    - 実装完了後、品質チェックを実施
3.  **レビュー & PR (`/rabbit-rocket`)**:
    - CodeRabbitによるレビューを実施
    - `develop`ブランチへのPRを作成
4.  **クリーンアップ (`/sync`)**:
    - PRマージ後、worktreeのクリーンアップを実施

## 既知の制限事項（v1）
- **視覚的類似性**: リサイズや軽微な編集が施された「類似」画像の検出は、計算コストと複雑性が高いためv1ではスコープ外。v1は完全なバイナリ重複に焦点を当てる
- **システムファイル**: OS破損を防ぐため、システムディレクトリ（`/System`, `/Library`）のスキャンは制限される

